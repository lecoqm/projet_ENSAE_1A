def one_way(self, path, node, nodes_known, power, max_nodes_per_path, nodes_in_path):
    while nodes_in_path < max_nodes_per_path : 
        if node != path[1] : 
            neighbors=[self.graph[node][i][0:1] for i in range(len(self.graph[node]))]
            for i in range(0,len(neighbors)):
                if neighbors[i][0] not in nodes_known :
                    node=neighbors[i][0]
                    nodes_known.append(node)
                    power.append(int(neighbors[i][1]))
                    nodes_in_path += 1
                    self.one_way([node,path[1]],nodes_known,power)
    return nodes_known, max(power), node 

max_path = 10 # chercher un nombre max dans le graphe : y'a surement un calcul possible 
max_nodes_per_path = 5 # chercher oÃ¹ il y a le nombre qui donne une limite possible comme le nombre de node dans le graphe...     

        
def min_power(self, path):
    minpower = float('inf')
    node = path[0]
    nodes_known = [path[0]]
    power=[]
    ways = []
    nodes_in_path = 1
    number_of_path = 0 
    while number_of_path < max_path : 
        way, p = self.one_way(path,node,nodes_known,power,nodes_in_path,max_nodes_per_path)
        if node == path[1] :
          if way not in ways :
              ways += [way]
              number_of_path += 1
              if p < minpower:
                  final_way = way
                  minpower = p
        else :
          way, p = self.one_way(path,node,nodes_known,power,nodes_in_path,max_nodes_per_path)
    return final_way, minpower

